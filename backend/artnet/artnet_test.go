package artnet

import (
	"backend/config"
	"bytes"
	"encoding/json"
	"log/slog"
	"net"
	"strings"
	"sync"
	"testing"
	"time"
)

func TestArtnet_Initialize(t *testing.T) {
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		t.Error(err)
	}
	targets := []net.Addr{}
	targetsIpv4 := []net.Addr{}
	for _, addr := range addrs {
		ip := addr.(*net.IPNet)
		if ip.IP.IsGlobalUnicast() {
			targets = append(targets, addr)
		}
		if ip.IP.To4() != nil {
			targetsIpv4 = append(targetsIpv4, addr)
		}
	}
	tests := []struct {
		name   string
		log    *slog.Logger
		config *config.Config
		want   bool
	}{
		{
			name: "localhost",
			log:  slog.New(slog.NewJSONHandler(t.Output(), &slog.HandlerOptions{Level: slog.LevelDebug})),
			config: &config.Config{
				Output: config.OutputTargets{
					Target: []string{"artnet"},
					Artnet: config.Artnet{
						Address:     "127.0.0.1",
						Universe:    0,
						SubUniverse: 0,
						Net:         0,
					},
				},
			},
			want: true,
		},
		{
			name: "empty address",
			log:  slog.New(slog.NewJSONHandler(t.Output(), &slog.HandlerOptions{Level: slog.LevelDebug})),
			config: &config.Config{
				Output: config.OutputTargets{
					Target: []string{"artnet"},
					Artnet: config.Artnet{
						Address:     "",
						Universe:    0,
						SubUniverse: 0,
						Net:         0,
					},
				},
			},
			want: false,
		},
		{
			name: "outrange test",
			log:  slog.New(slog.NewJSONHandler(t.Output(), &slog.HandlerOptions{Level: slog.LevelDebug})),
			config: &config.Config{
				Output: config.OutputTargets{
					Target: []string{"artnet"},
					Artnet: config.Artnet{
						Address:     "254.254.254.254",
						Universe:    0,
						SubUniverse: 0,
						Net:         0,
					},
				},
			},
			want: false,
		},
	}
	for _, target := range targets {
		tests = append(tests,
			struct {
				name   string
				log    *slog.Logger
				config *config.Config
				want   bool
			}{
				name: "Can only use IPv4",
				log:  slog.New(slog.NewJSONHandler(t.Output(), &slog.HandlerOptions{Level: slog.LevelDebug})),
				config: &config.Config{
					Output: config.OutputTargets{
						Target: []string{"artnet"},
						Artnet: config.Artnet{
							Address:     target.(*net.IPNet).IP.String(),
							Universe:    0,
							SubUniverse: 0,
							Net:         0,
						},
					},
				},
				want: target.(*net.IPNet).IP.To4() != nil,
			})
	}
	for _, target := range targetsIpv4 {
		outrange := target.(*net.IPNet).IP
		outrange[3] += 1
		tests = append(tests,
			struct {
				name   string
				log    *slog.Logger
				config *config.Config
				want   bool
			}{
				name: "Outrange",
				log:  slog.New(slog.NewJSONHandler(t.Output(), &slog.HandlerOptions{Level: slog.LevelDebug})),
				config: &config.Config{
					Output: config.OutputTargets{
						Target: []string{"artnet"},
						Artnet: config.Artnet{
							Address:     outrange.String(),
							Universe:    0,
							SubUniverse: 0,
							Net:         0,
						},
					},
				},
				want: false,
			})
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			encodedJson, _ := json.Marshal(tt.config)
			t.Log("data: " + string(encodedJson))
			var a Artnet = Artnet{
				TargetAddr: tt.config.Output.Artnet.Address,
			}
			got := a.Initialize(tt.log, tt.config)
			defer a.Stop()
			t.Logf("result: %v, want %v", got, tt.want)
			if tt.want != got {
				t.Errorf("Initialize() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestArtnet_Start_Stop(t *testing.T) {
	tests := []struct {
		name string
		want bool
	}{
		{
			name: "isSuccess",
			want: true,
		},
		{
			name: "isFailed",
			want: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var a Artnet = Artnet{
				TargetAddr: "127.0.0.1",
			}
			a.Initialize(slog.New(slog.NewJSONHandler(t.Output(), &slog.HandlerOptions{Level: slog.LevelDebug})), &config.Config{
				Output: config.OutputTargets{
					Target: []string{"artnet"},
					Artnet: config.Artnet{
						Address:     a.TargetAddr,
						Universe:    0,
						SubUniverse: 0,
						Net:         0,
					},
				},
			})
			if !tt.want {
				a.sourceUDP = &net.UDPAddr{
					IP:   net.IPv4(254, 254, 254, 254),
					Port: 6454,
				}
			}
			got := a.Start()
			if tt.want {
				defer a.Stop()
				a.socket.Close()
			}
			if got != tt.want {
				t.Errorf("Start() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestArtnet_listen(t *testing.T) {
	tests := []struct {
		name      string
		data      []byte
		outputLog bool
	}{
		{
			name:      "ArtPoll",
			data:      []byte{0x41, 0x72, 0x74, 0x2d, 0x4e, 0x65, 0x74, 0x0, 0x0, 0x20, 0x0, 0xe, 0x2, 0x0},
			outputLog: true,
		},
		{
			name: "ArtDMX",
			data: []byte{
				0x41, 0x72, 0x74, 0x2d, 0x4e, 0x65, 0x74, 0x00, 0x00, 0x50, 0x00, 0x0e, 0x0b, 0x00, 0x00, 0x00,
				0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00},
			outputLog: false,
		},
		{
			name: "ArtPollRep",
			data: []byte{
				0x41, 0x72, 0x74, 0x2d, 0x4e, 0x65, 0x74, 0x00, 0x00, 0x21, 0x7f, 0x00, 0x00, 0x01, 0x36, 0x19,
				0x04, 0x20, 0x00, 0x00, 0xff, 0xff, 0x00, 0xf0, 0xff, 0xff, 0x51, 0x4c, 0x43, 0x2b, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x20, 0x4c, 0x69,
				0x67, 0x68, 0x74, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x20, 0x50,
				0x6c, 0x75, 0x73, 0x20, 0x2d, 0x20, 0x41, 0x72, 0x74, 0x4e, 0x65, 0x74, 0x20, 0x69, 0x6e, 0x74,
				0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			outputLog: true,
		},
		{
			name:      "ArtSync",
			data:      []byte{0x41, 0x72, 0x74, 0x2D, 0x4E, 0x65, 0x74, 0x00, 0x00, 0x52, 0x00, 0x14, 0x00, 0x00},
			outputLog: true,
		},
		{
			name:      "No Artnet command",
			data:      []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08},
			outputLog: false,
		},
	}
	var lock sync.Mutex
	for _, tt := range tests {
		var buf bytes.Buffer
		config := config.Config{
			Output: config.OutputTargets{
				Target: []string{"artnet"},
				Artnet: config.Artnet{
					Address:     "127.0.0.1",
					Universe:    3,
					SubUniverse: 2,
					Net:         1,
				},
			},
		}
		t.Run(tt.name, func(t *testing.T) {
			logger := slog.New(slog.NewJSONHandler(&buf, &slog.HandlerOptions{
				Level: slog.LevelDebug,
			}))
			lock.Lock()
			defer lock.Unlock()
			var a Artnet = Artnet{
				TargetAddr: config.Output.Artnet.Address,
			}
			if !a.Initialize(logger, &config) {
				t.Error("Failed to initialize")
			}
			a.Start()
			defer a.Stop()
			conn, err := net.Dial("udp", "127.0.0.1:6454")
			if err != nil {
				t.Error("Failed to Open UDP socket")
			}
			defer conn.Close()
			size, err := conn.Write(tt.data)
			if err != nil {
				t.Fail()
			}
			if size <= 0 {
				t.Error("Data is not none")
			}
			var targetLog string = ""
			time.Sleep(100 * time.Millisecond)
			for range 3 {
				targetLog, err = buf.ReadString('\n')
				if err != nil {
					t.Log(err)
					break
				}
				t.Logf("log: %s", targetLog)
				if strings.Contains(targetLog, "\"dir\":\"recv\"") {
					break
				}
				targetLog = ""
			}
			if tt.outputLog {
				if targetLog == "" {
					t.Errorf("Log is none.")
				}
			} else {
				if targetLog != "" {
					t.Errorf("Log is Contains.")
				}
			}
			t.Log("target log: " + string(targetLog))
		})
	}
}

func TestArtnet_RenderData(t *testing.T) {
	tests := []struct {
		name string
		op   string
		data []byte
		want []byte
	}{
		{
			name: "Generate OpDMX",
			op:   "OpDMX",
			data: []byte{
				0x00,
			},
			want: []byte{
				0x41, 0x72, 0x74, 0x2d, 0x4e, 0x65, 0x74, 0x00, 0x00, 0x50, 0x00, 0x0e,
				0x00,
			},
		},
		{
			name: "Generate OpPoll",
			op:   "OpPoll",
			data: []byte{
				0x00,
			},
			want: []byte{
				0x41, 0x72, 0x74, 0x2d, 0x4e, 0x65, 0x74, 0x00, 0x00, 0x20, 0x00, 0x0e,
				0x00,
			},
		},
		{
			name: "Generate OpPollRep",
			op:   "OpPollRep",
			data: []byte{
				0x00,
			},
			want: []byte{
				0x41, 0x72, 0x74, 0x2d, 0x4e, 0x65, 0x74, 0x00, 0x00, 0x21, 0x00, 0x0e,
				0x00,
			},
		},
	}
	logger := slog.New(slog.NewJSONHandler(t.Output(), &slog.HandlerOptions{Level: slog.LevelDebug}))
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var a Artnet = Artnet{
				TargetAddr: "127.0.0.1",
			}
			config := config.Config{
				Output: config.OutputTargets{
					Target: []string{"artnet"},
					Artnet: config.Artnet{
						Address:     a.TargetAddr,
						Universe:    3,
						SubUniverse: 2,
						Net:         1,
					},
				},
			}
			a.Initialize(logger, &config)
			got := a.RenderData(tt.op, &tt.data)
			if !bytes.Equal(*got, tt.want) {
				t.Errorf("RenderData() = %v, want %v", got, tt.want)
			}
			t.Logf("generated: %v", got)
		})
	}
}

func TestArtnet_SendDMXData(t *testing.T) {
	header := append([]byte("Art-Net"), 0, 0x00, 0x50, 0, 14)
	allZero := make([]byte, 512)
	increment := make([]byte, 512)
	for i := range len(increment) {
		increment[i] = byte(i)
	}
	tests := []struct {
		name        string
		data        []byte
		universe    uint8
		subUniverse uint8
		net         uint8
		sequence    uint8
		want        []byte
	}{
		{
			name:        "All Zero",
			data:        allZero,
			universe:    0,
			subUniverse: 0,
			net:         0,
			sequence:    0,
			want:        append(header, append([]byte{0, 0, 0, 0, 0x2, 0}, allZero...)...),
		},
		{
			name:        "Increment",
			data:        increment,
			universe:    3,
			subUniverse: 2,
			net:         1,
			sequence:    255,
			want:        append(header, append([]byte{0xff, 0, 0x23, 0x1, 0x2, 0}, increment...)...),
		},
	}
	var lock sync.Mutex
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			logger := slog.New(slog.NewJSONHandler(t.Output(), &slog.HandlerOptions{Level: slog.LevelDebug}))
			lock.Lock()
			defer lock.Unlock()
			var a Artnet = Artnet{
				TargetAddr: "127.0.0.1",
			}
			config := config.Config{
				Output: config.OutputTargets{
					Target: []string{"artnet"},
					Artnet: config.Artnet{
						Address:     a.TargetAddr,
						Universe:    tt.universe,
						SubUniverse: tt.subUniverse,
						Net:         tt.net,
					},
				},
			}
			static.rmtPort = 6455
			defer func() { static.rmtPort = 6454 }()
			if !a.Initialize(logger, &config) {
				t.Error("Failed to initialize artnet.")
				return
			}
			a.Start()
			defer a.socket.Close()
			defer a.Stop()
			addr, _ := net.ResolveUDPAddr("udp", "127.0.0.1:6455")
			conn, err := net.ListenUDP("udp", addr)
			if err != nil {
				t.Errorf("Failed to Open UDP socket: %v", err)
				return
			}
			defer conn.Close()
			readData := make(chan []byte)
			conn.SetDeadline(time.Now().Add(3 * time.Second))
			go func() {
				data := make([]byte, 1024)
				len, err := conn.Read(data)
				if err != nil {
					t.Errorf("Socket error. %v", err)
				}
				if len <= 0 {
					t.Error("Data is not send.")
				}
				t.Log(data[:len])
				readData <- data[:len]
			}()
			sequence = tt.sequence
			a.SendDMXData(&tt.data)
			t.Log("Send")
			var data []byte
			select {
			case data = <-readData:
				break
			case <-time.After(3 * time.Second):
				t.Error("Timeout")
				return
			}
			if !bytes.Equal(data, tt.want) {
				t.Errorf("Failed to match data. %v want %v", data, tt.want)
				return
			}
			t.Logf("Matched: %v", data)
		})
	}
}
